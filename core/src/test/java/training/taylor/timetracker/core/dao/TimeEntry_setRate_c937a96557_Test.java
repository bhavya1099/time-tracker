// ********RoostGPT********
/*
Test generated by RoostGPT for test java-junit4-test using AI Type Open AI and AI Model gpt-4

1. **Positive Scenario - Valid Rate**: Test whether the function sets the rate correctly when a valid float value is passed. 

2. **Negative Scenario - Negative Rate**: Test whether the function handles negative values correctly. According to business rules, the rate should not be negative. The function should either prevent setting the rate as negative or throw an error.

3. **Boundary Scenario - Zero Rate**: Test whether the function handles zero as an input correctly. Depending on the business rules, the rate might or might not be allowed to be zero.

4. **Boundary Scenario - Maximum Rate**: Test whether the function handles maximum float value correctly. It should not cause any overflow issues.

5. **Negative Scenario - Null Rate**: Although this is not possible in this case (as float is a primitive type and cannot be null), if the function was to accept Float instead of float, you would need a scenario to test how the function handles null values.

6. **Positive Scenario - Decimal Rate**: Test whether the function correctly sets the rate when a decimal float value is passed. 

7. **Negative Scenario - Exceeding Precision**: Test how the function handles values that exceed the precision of float.

8. **Positive Scenario - Minimum Rate**: Test the function with the smallest possible positive float value. The function should still work correctly.

9. **Stress Scenario - Rapid Rate Changes**: Test the function under stress by setting the rate rapidly in a short period of time. The function should continue to behave correctly.

10. **Negative Scenario - NaN Rate**: Test how the function handles NaN (Not a Number) values.
*/

// ********RoostGPT********
package training.taylor.timetracker.core.dao;

import org.junit.Test;
import static org.junit.Assert.*;

public class TimeEntry_setRate_c937a96557_Test {

    @Test
    public void testSetRateValid() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = 50.0f;
        timeEntry.setRate(rate);
        assertEquals(rate, timeEntry.getRate(), 0.0);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testSetRateNegative() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = -10.0f;
        timeEntry.setRate(rate);
    }

    @Test
    public void testSetRateZero() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = 0.0f;
        timeEntry.setRate(rate);
        assertEquals(rate, timeEntry.getRate(), 0.0);
    }

    @Test
    public void testSetRateMaxFloat() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = Float.MAX_VALUE;
        timeEntry.setRate(rate);
        assertEquals(rate, timeEntry.getRate(), 0.0);
    }

    @Test
    public void testSetRateDecimal() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = 50.5f;
        timeEntry.setRate(rate);
        assertEquals(rate, timeEntry.getRate(), 0.0);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testSetRateExceedingPrecision() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = 50.123456789f; // More than 7 decimal places
        timeEntry.setRate(rate);
    }

    @Test
    public void testSetRateMinFloat() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = Float.MIN_VALUE;
        timeEntry.setRate(rate);
        assertEquals(rate, timeEntry.getRate(), 0.0);
    }

    @Test
    public void testSetRateRapidChanges() {
        TimeEntry timeEntry = new TimeEntry();
        for (int i = 0; i < 1000; i++) {
            float rate = i;
            timeEntry.setRate(rate);
            assertEquals(rate, timeEntry.getRate(), 0.0);
        }
    }

    @Test(expected = IllegalArgumentException.class)
    public void testSetRateNaN() {
        TimeEntry timeEntry = new TimeEntry();
        float rate = Float.NaN;
        timeEntry.setRate(rate);
    }
}
