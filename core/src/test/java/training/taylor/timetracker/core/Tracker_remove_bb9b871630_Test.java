// ********RoostGPT********
/*
Test generated by RoostGPT for test demoTestGitlab using AI Type Open AI and AI Model gpt-4

1. Scenario: Removing an existing entry
   Description: Validate that when the "remove" function is called with an existing TimeEntry object, the entry is successfully removed from the list.

2. Scenario: Removing a non-existent entry
   Description: Validate that when the "remove" function is called with a TimeEntry object that does not exist in the list, the list remains unchanged.

3. Scenario: Removing a null entry
   Description: Validate that when the "remove" function is called with a null object, a NullPointerException is thrown.

4. Scenario: Removing an entry from an empty list
   Description: Validate that when the "remove" function is called on an empty list, the list remains empty and no exception is thrown.

5. Scenario: Removing an entry multiple times
   Description: Validate that when the "remove" function is called multiple times with the same TimeEntry object, the entry is removed only once and subsequent calls do not affect the list.

6. Scenario: Removing an entry from a list with duplicate entries
   Description: Validate that when the "remove" function is called with a TimeEntry object that exists multiple times in the list, only one instance of the entry is removed.

7. Scenario: Removing multiple different entries
   Description: Validate that when the "remove" function is called multiple times with different TimeEntry objects, all specified entries are successfully removed from the list. 

8. Scenario: Thread safety when removing an entry
   Description: Validate that when the "remove" function is called simultaneously from multiple threads with the same or different TimeEntry objects, the operation is performed safely and correctly.
*/

// ********RoostGPT********
package training.taylor.timetracker.core;

import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import training.taylor.timetracker.core.dao.TimeEntry;

import java.util.ArrayList;
import java.util.List;

import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class Tracker_remove_bb9b871630_Test {

    @InjectMocks
    Tracker tracker;

    @Mock
    TimeEntry timeEntry;

    @Mock
    List<TimeEntry> entries;

    @Test
    public void testRemoveExistingEntry() {
        List<TimeEntry> entryList = new ArrayList<>();
        entryList.add(timeEntry);
        when(entries.size()).thenReturn(1);
        when(entries.contains(timeEntry)).thenReturn(true);
        when(entries.remove(timeEntry)).thenReturn(true);

        tracker.remove(timeEntry);
        verify(entries, times(2)).remove(timeEntry);
    }

    @Test
    public void testRemoveNonExistentEntry() {
        when(entries.contains(timeEntry)).thenReturn(false);
        tracker.remove(timeEntry);
        verify(entries, times(2)).remove(timeEntry);
    }

    @Test(expected = NullPointerException.class)
    public void testRemoveNullEntry() {
        tracker.remove(null);
    }

    @Test
    public void testRemoveEntryFromEmptyList() {
        when(entries.isEmpty()).thenReturn(true);
        tracker.remove(timeEntry);
        verify(entries, times(2)).remove(timeEntry);
    }

    @Test
    public void testRemoveEntryMultipleTimes() {
        when(entries.contains(timeEntry)).thenReturn(true).thenReturn(false);
        tracker.remove(timeEntry);
        tracker.remove(timeEntry);
        verify(entries, times(4)).remove(timeEntry);
    }

    @Test
    public void testRemoveDuplicateEntries() {
        List<TimeEntry> entryList = new ArrayList<>();
        entryList.add(timeEntry);
        entryList.add(timeEntry);
        when(entries.size()).thenReturn(2);
        when(entries.contains(timeEntry)).thenReturn(true);
        when(entries.remove(timeEntry)).thenReturn(true);

        tracker.remove(timeEntry);
        verify(entries, times(2)).remove(timeEntry);
    }

    @Test
    public void testRemoveMultipleDifferentEntries() {
        TimeEntry timeEntry2 = mock(TimeEntry.class);
        List<TimeEntry> entryList = new ArrayList<>();
        entryList.add(timeEntry);
        entryList.add(timeEntry2);
        when(entries.size()).thenReturn(2);
        when(entries.contains(timeEntry)).thenReturn(true);
        when(entries.contains(timeEntry2)).thenReturn(true);
        when(entries.remove(timeEntry)).thenReturn(true);
        when(entries.remove(timeEntry2)).thenReturn(true);

        tracker.remove(timeEntry);
        tracker.remove(timeEntry2);
        verify(entries).remove(timeEntry);
        verify(entries).remove(timeEntry2);
    }

    @Test
    public void testThreadSafetyWhenRemovingAnEntry() {
        Thread thread1 = new Thread(() -> tracker.remove(timeEntry));
        Thread thread2 = new Thread(() -> tracker.remove(timeEntry));

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        verify(entries, times(4)).remove(timeEntry);
    }
}
