// ********RoostGPT********
/*
Test generated by RoostGPT for test java-junit4-test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=get_e1a8701275
ROOST_METHOD_SIG_HASH=get_1b945bb04e

================================VULNERABILITIES================================
Vulnerability: CWE-470: Unrestricted Use of System/Utility Programs
Issue: The code uses an unrestricted try-catch block to handle exceptions. This can lead to the hiding of important error information, making it difficult to identify and fix bugs or security vulnerabilities that may arise during the execution of the program.
Solution: Specifically catch the exceptions that you expect to be thrown rather than using a generic Exception class. If an unexpected exception is thrown, let it propagate up to a higher level where it can be caught and handled appropriately.

Vulnerability: CWE-480: Use of Incorrect Operator
Issue: The code uses a single equal sign (=) in a conditional expression (if statement). This is actually an assignment operator in Java, not a comparison operator. As a result, the condition will always evaluate to true, which could lead to unexpected behavior.
Solution: Use the double equals (==) for comparison in the if statement. Always use '==' for comparing primitive types and '.equals()' for comparing objects in Java.

Vulnerability: CWE-476: NULL Pointer Dereference
Issue: The code does not check if 'entries' is null before calling 'entries.get(index)'. This can lead to a NullPointerException, causing the program to crash.
Solution: Always check if an object is null before calling methods on it. The null check should be done as follows: 'if (entries != null) {return entries.get(index);}'.

================================================================================
1. Scenario: Validate that the `get` method returns the correct `TimeEntry` object at the given index.
   Test Steps:
   - Create a list of `TimeEntry` objects.
   - Call the `get` method with an index.
   - Verify that the returned `TimeEntry` object is the same as the one at the given index in the list.

2. Scenario: Validate that the `get` method throws an `IndexOutOfBoundsException` when the index is out of bounds.
   Test Steps:
   - Create a list of `TimeEntry` objects.
   - Call the `get` method with an index that is out of bounds.
   - Verify that an `IndexOutOfBoundsException` is thrown.

3. Scenario: Validate that the `get` method does not throw any exception when the list is empty and the index is 0.
   Test Steps:
   - Create an empty list of `TimeEntry` objects.
   - Call the `get` method with an index of 0.
   - Verify that no exception is thrown.

4. Scenario: Validate that the `get` method throws an `IndexOutOfBoundsException` when the list is empty and the index is greater than 0.
   Test Steps:
   - Create an empty list of `TimeEntry` objects.
   - Call the `get` method with an index greater than 0.
   - Verify that an `IndexOutOfBoundsException` is thrown.

5. Scenario: Validate that the `get` method returns null when the `TimeEntry` object at the given index is null.
   Test Steps:
   - Create a list of `TimeEntry` objects with a null object at a certain index.
   - Call the `get` method with the index of the null object.
   - Verify that the returned `TimeEntry` object is null.

6. Scenario: Validate that the `get` method functions correctly with a large list of `TimeEntry` objects.
   Test Steps:
   - Create a large list of `TimeEntry` objects.
   - Call the `get` method with various indexes.
   - Verify that the returned `TimeEntry` objects are the same as those at the given indexes in the list.

7. Scenario: Validate that the `get` method functions correctly when called multiple times in succession.
   Test Steps:
   - Create a list of `TimeEntry` objects.
   - Call the `get` method multiple times in succession with different indexes.
   - Verify that the returned `TimeEntry` objects are the same as those at the given indexes in the list.
*/

// ********RoostGPT********
package training.taylor.timetracker.core;

import org.junit.Before;
import org.junit.Test;
import training.taylor.timetracker.core.dao.TimeEntry;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

public class Tracker_get_1b945bb04e_Test {

    private Tracker tracker;
    private TimeEntry timeEntry1;
    private TimeEntry timeEntry2;

    @Before
    public void setup() {
        tracker = new Tracker();
        timeEntry1 = new TimeEntry();
        timeEntry2 = new TimeEntry();
    }

    @Test
    public void testGet() {
        List<TimeEntry> entries = new ArrayList<>(Arrays.asList(timeEntry1, timeEntry2));
        tracker.add(timeEntry1);
        tracker.add(timeEntry2);

        assertEquals(timeEntry1, tracker.get(0));
        assertEquals(timeEntry2, tracker.get(1));
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void testGet_IndexOutOfBounds() {
        tracker.add(timeEntry1);

        tracker.get(2);
    }

    @Test
    public void testGet_EmptyList() {
        assertEquals(0, tracker.size());

        assertNull(tracker.get(0));
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void testGet_EmptyList_IndexOutOfBounds() {
        assertEquals(0, tracker.size());

        tracker.get(1);
    }

    @Test
    public void testGet_NullObject() {
        tracker.add(null);

        assertNull(tracker.get(0));
    }

    @Test
    public void testGet_LargeList() {
        for (int i = 0; i < 1000; i++) {
            tracker.add(new TimeEntry());
        }

        assertEquals(1000, tracker.size());
        assertEquals(timeEntry1, tracker.get(0));
        assertEquals(timeEntry2, tracker.get(1));
    }

    @Test
    public void testGet_MultipleTimes() {
        tracker.add(timeEntry1);
        tracker.add(timeEntry2);

        assertEquals(timeEntry1, tracker.get(0));
        assertEquals(timeEntry2, tracker.get(1));
        assertEquals(timeEntry1, tracker.get(0));
    }
}
